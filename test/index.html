<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>SwarmCraft Minimal Test Client</title>
    <style>
      body {
        font-family: sans-serif;
        display: flex;
        gap: 20px;
        padding: 20px;
        background-color: #f0f0f0;
      }
      .controls,
      .logs {
        display: flex;
        flex-direction: column;
        gap: 10px;
      }
      .controls div {
        display: flex;
        flex-direction: column;
        gap: 4px;
        margin-bottom: 10px;
      }
      .main-content {
        display: flex;
        flex-direction: column;
        gap: 20px;
      }
      #grid-container {
        display: grid;
        border: 2px solid #333;
        background-color: #fff;
      }
      .grid-cell {
        width: 20px;
        height: 20px;
        box-shadow: inset 0 0 0 1px #ddd;
        position: relative;
      }
      .particle-marker {
        width: 16px;
        height: 16px;
        border-radius: 50%;
        border: 1px solid white;
        transition: all 0.5s ease-in-out; /* Animate color and position changes */
        margin: auto;
      }
      #cards-container {
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
      }
      .participant-card {
        padding: 10px;
        border-radius: 5px;
        border: 1px solid #ccc;
        min-width: 200px;
        color: white;
        text-shadow: 1px 1px 2px black;
      }
      #log-output {
        background-color: #333;
        color: #lime;
        padding: 10px;
        height: 400px;
        overflow-y: scroll;
        white-space: pre-wrap;
        font-family: monospace;
      }
      button:disabled {
        background-color: #ccc;
        cursor: not-allowed;
      }
    </style>
  </head>
  <body>
    <div class="controls">
      <h2>Controls</h2>
      <div>
        <label for="admin-key">Admin Key (SWARM_API_KEY)</label>
        <input
          type="password"
          id="admin-key"
          placeholder="Paste your key from .env file"
        />
      </div>
      <div>
        <label for="landscape-type">Landscape</label>
        <select id="landscape-type">
          <option value="quadratic" selected>Quadratic (Easy)</option>
          <option value="rastrigin">Rastrigin (Hard)</option>
          <option value="ecological">Ecological (Complex)</option>
        </select>
      </div>
      <div>
        <label for="max-iterations">Max Iterations (for cooldown)</label>
        <input type="number" id="max-iterations" value="20" />
      </div>
      <div>
        <label for="num-participants">Number of Participants</label>
        <input type="number" id="num-participants" value="10" />
      </div>
      <button id="setup-btn">1. Setup & Join Session</button>
      <button id="start-btn" disabled>2. Start Session</button>
      <button id="step-btn" disabled>3. Trigger Step</button>
    </div>

    <div class="main-content">
      <div id="grid-container"></div>
      <div id="cards-container"></div>
    </div>

    <div class="logs">
      <h2>Event Log</h2>
      <div id="log-output"></div>
    </div>
  </body>
  <script>
    // --- CONFIG ---
    const API_BASE_URL = "http://localhost:8000";
    const WS_BASE_URL = "ws://localhost:8000";

    // --- STATE ---
    let sessionData = {};
    let participants = {};
    let websockets = {};

    // --- DOM ELEMENTS ---
    const adminKeyInput = document.getElementById("admin-key");
    const landscapeTypeInput = document.getElementById("landscape-type");
    const maxIterationsInput = document.getElementById("max-iterations");
    const numParticipantsInput = document.getElementById("num-participants");
    const setupBtn = document.getElementById("setup-btn");
    const startBtn = document.getElementById("start-btn");
    const stepBtn = document.getElementById("step-btn");
    const gridContainer = document.getElementById("grid-container");
    const cardsContainer = document.getElementById("cards-container");
    const logOutput = document.getElementById("log-output");

    // --- LOGIC ---
    const logMessage = (message, data) => {
      const fullMessage = data
        ? `${message}: ${JSON.stringify(data, null, 2)}`
        : message;
      console.log(fullMessage);
      logOutput.innerHTML += `<div>${new Date().toLocaleTimeString()}: ${message}</div>`;
      logOutput.scrollTop = logOutput.scrollHeight;
    };

    const render = () => {
      if (!sessionData.config) return;
      gridContainer.innerHTML = "";
      gridContainer.style.gridTemplateColumns = `repeat(${sessionData.config.grid_size}, 22px)`;
      for (
        let i = 0;
        i < sessionData.config.grid_size * sessionData.config.grid_size;
        i++
      ) {
        const cell = document.createElement("div");
        cell.className = "grid-cell";
        gridContainer.appendChild(cell);
      }
      cardsContainer.innerHTML = "";
      for (const p of Object.values(participants)) {
        const card = document.createElement("div");
        card.className = "participant-card";
        card.id = `card-${p.id}`;
        card.style.backgroundColor = p.color || "#888";
        card.innerHTML = `
                    <b>${p.name} (${p.id})</b><br>
                    Position: [${p.position ? p.position.join(", ") : "N/A"}]<br>
                    Fitness: ${p.fitness ? p.fitness.toFixed(2) : "N/A"}<br>
                    Speed: ${p.velocity_magnitude ? p.velocity_magnitude.toFixed(2) : "N/A"}
                `;
        cardsContainer.appendChild(card);
        if (p.position) {
          // Find existing marker or create new one
          let marker = document.getElementById(`marker-${p.id}`);
          if (!marker) {
            marker = document.createElement("div");
            marker.className = "particle-marker";
            marker.id = `marker-${p.id}`;
            gridContainer.appendChild(marker);
          }
          marker.style.backgroundColor = p.color || "#888";
          const [row, col] = p.position;
          marker.style.gridRowStart = row + 1;
          marker.style.gridColumnStart = col + 1;
        }
      }
    };

    const handleWebSocketMessage = (event) => {
      const data = JSON.parse(event.data);
      logMessage(`WebSocket received: ${data.type}`);

      if (data.type === "session_state" || data.type === "session_started") {
        // This block might not be needed if session_started also sends a full state,
        // but it's good for robustness.
        if (data.session) {
          Object.assign(sessionData, data.session);
          for (const p of data.session.participants) {
            if (participants[p.id]) {
              Object.assign(participants[p.id], p);
            }
          }
        }
        render();
      } else if (data.type === "swarm_update") {
        sessionData.iteration = data.iteration;
        const stats = data.statistics;
        logMessage(
          `  -> Iteration: ${data.iteration}, Explorers: ${stats.explorers}, ` +
            `Explore P: ${stats.exploration_probability.toFixed(3)}, ` +
            `Best Fit: ${stats.global_best_fitness.toFixed(3)}`,
        );

        // Update participants with new data from the swarm_update message
        for (const p_data of data.participants) {
          if (participants[p_data.id]) {
            Object.assign(participants[p_data.id], p_data);
          }
        }
        render();
      } else if (data.type === "participant_moved") {
        const p = participants[data.participant_id];
        if (p) {
          p.position = data.position;
          p.fitness = data.fitness;
          render();
        }
      }
    };

    setupBtn.addEventListener("click", async () => {
      logMessage("Setting up session...");
      const adminKey = adminKeyInput.value;
      if (!adminKey) {
        logMessage(
          "ERROR: Admin key is required. Please paste it from your .env file.",
        );
        return;
      }
      setupBtn.disabled = true;

      const landscapeType = landscapeTypeInput.value;
      const maxIterations = parseInt(maxIterationsInput.value, 10);

      try {
        logMessage(
          `1. Creating session (${landscapeType}, ${maxIterations} iterations)...`,
        );
        const createRes = await fetch(
          `${API_BASE_URL}/api/admin/create-session`,
          {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              "X-Admin-Key": adminKey,
            },
            body: JSON.stringify({
              landscape_type: landscapeType,
              grid_size: 20,
              max_participants: 50,
              exploration_probability: 0.25,
              min_exploration_probability: 0.01,
              max_iterations: maxIterations,
            }),
          },
        );

        if (!createRes.ok) {
          const errorText = await createRes.text();
          throw new Error(
            `Failed to create session: ${createRes.status} ${errorText}`,
          );
        }

        const createData = await createRes.json();
        sessionData.id = createData.session_id;
        sessionData.code = createData.session_code;

        logMessage("--> Session created!", createData);
        logMessage("------------------------------------------");
        logMessage(
          `To connect another client (like test_websocket.py), use Session ID: ${sessionData.id}`,
        );
        logMessage("------------------------------------------");

        logMessage("2. Joining participants...");
        const numParticipants = parseInt(numParticipantsInput.value, 10);
        for (let i = 0; i < numParticipants; i++) {
          const joinRes = await fetch(
            `${API_BASE_URL}/api/join/${sessionData.code}`,
            { method: "POST" },
          );

          if (!joinRes.ok) {
            const errorData = await joinRes.json();
            throw new Error(
              `Participant ${i + 1} failed to join: ${JSON.stringify(errorData)}`,
            );
          }

          const pData = await joinRes.json();
          const participantId = pData.participant_id;
          participants[participantId] = { ...pData, color: "#888" };
          logMessage(
            `   ${pData.participant_name} joined with ID ${participantId}.`,
          );

          logMessage(`3. Opening WebSocket for ${participantId}...`);
          const ws = new WebSocket(
            `${WS_BASE_URL}/ws/${sessionData.id}/${participantId}`,
          );
          ws.onmessage = handleWebSocketMessage;
          ws.onopen = () =>
            logMessage(`   WebSocket connected for ${participantId}.`);
          ws.onerror = (err) =>
            logMessage(
              `   WebSocket error for ${participantId}: ${JSON.stringify(err)}`,
            );
          websockets[participantId] = ws;
        }

        const statusRes = await fetch(
          `${API_BASE_URL}/api/session/${sessionData.id}/status`,
        );
        sessionData.config = await statusRes.json();

        render();
        startBtn.disabled = false;
      } catch (error) {
        logMessage(`ERROR: ${error.message}`);
        setupBtn.disabled = false;
      }
    });

    startBtn.addEventListener("click", async () => {
      logMessage("Starting session...");
      startBtn.disabled = true;
      try {
        const res = await fetch(
          `${API_BASE_URL}/api/admin/session/${sessionData.id}/start`,
          {
            method: "POST",
            headers: { "X-Admin-Key": adminKeyInput.value },
          },
        );
        if (!res.ok)
          throw new Error(`Failed to start session: ${await res.text()}`);

        logMessage("Session started! Ready to trigger steps.");
        stepBtn.disabled = false;
      } catch (error) {
        logMessage(`ERROR: ${error.message}`);
        startBtn.disabled = false;
      }
    });

    stepBtn.addEventListener("click", async () => {
      logMessage("Triggering step...");
      try {
        const res = await fetch(
          `${API_BASE_URL}/api/admin/session/${sessionData.id}/step`,
          {
            method: "POST",
            headers: { "X-Admin-Key": adminKeyInput.value },
          },
        );
        if (!res.ok)
          throw new Error(`Failed to trigger step: ${await res.text()}`);

        const resData = await res.json();
        // The detailed log is now handled by the 'swarm_update' websocket message
        logMessage(resData.message);
      } catch (error) {
        logMessage(`ERROR: ${error.message}`);
      }
    });
  </script>
</html>
